from copy import deepcopy

import time, re

global directions, charToNum, computerMoveDelay
directions = [(1, 0), (1, 1), (0, 1), (-1, 0), (-1, -1), (0, -1), (1, -1), (-1, 1)]
charToNum = "abcdefgh"
compMoveDelay = 1

def newGame(player1, player2):

    game = {
        'player1': player1,
        'player2': player2,
        'who': 1,
        'board': [[0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 2, 1, 0, 0, 0],
                  [0, 0, 0, 1, 2, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0, 0, 0, 0]]
    }
    return game

def printBoard(board):

    def cellEval(n):
        if (n == 1):
            return 'X'
        elif (n == 2):
            return 'O'
        else:
            return ' '

    divLine = ' +' + '-+' * 8
    print(' |a|b|c|d|e|f|g|h|')
    print(divLine)

    for index, line in enumerate(board):
        print(str(index + 1) + '|', end='')
        [list(map(lambda cell: print(cellEval(cell) + '|', end=''), line))]
        print()

    print(divLine)

    return

def strToIndex(s):

    s = str().join((re.findall("\w", s.lower())))
    row = re.findall("[1-8]", s)
    column = re.findall("[a-h]", s)

    if (len(s) == 2) and (len(row) == len(column) == 1):
        return ((int(row[0]) - 1, charToNum.index(column[0])))
    else:
        raise ValueError()
    return

def indexToStr(tup):

    return (charToNum[tup[1]] + str(tup[0] + 1))

def loadGame():

    try:
        f = open("game.txt", mode="rt", encoding="utf8")
    except FileNotFoundError:
        raise FileNotFoundError()

    try:
        data = f.read().splitlines()

        game = {
            'player1': data[0],
            'player2': data[1],
            'who': data[2],
            'board': [list(map(int, i.split(','))) for i in data[3:]]
        }

        if (
                type(game['player1']) == type(game['player2']) == type(game['who']) == str
                and
                0 not in (len(game['player1']), len(game['player2']), len(game['who']))
                and
                all(len(line) == len(game['board']) == 8 for line in game['board'])
        ):

            return game

        else:
            raise ValueError()

    except:
        raise ValueError()


def getLine(board, who, pos, dir):

    dir = tuple(map(lambda x: int(x / abs(x)) if (x != 0) else 0, dir))
    giveLine = []

    while True:
        pos = tuple(map(sum, zip(pos, dir)))
        if ((-1 in pos) or (8 in pos)):
            return []
        elif (board[pos[0]][pos[1]] == 3 - who):
            giveLine.append(pos)
        elif (board[pos[0]][pos[1]] == who):
            return giveLine
        else:
            return []

def getValidMoves(board, who):

    def inverseGetLine(board, who, pos, dir):

        dir = tuple(map(lambda x: int(x / abs(x)) if (x != 0) else 0, dir))
        lineCount = 0

        while True:
            pos = tuple(map(sum, zip(pos, dir)))
            if ((-1 in pos) or (8 in pos)):
                return []
            elif (board[pos[0]][pos[1]] == 3 - who):
                lineCount += 1
            elif (lineCount > 0 and board[pos[0]][pos[1]] == 0):
                return pos
            else:
                return []

    moves = []

    for row in range(0, 7, 1):
        if (board[row] != [0, 0, 0, 0, 0, 0, 0, 0]) and (who in board[row]):
            for column in range(0, 7, 1):
                if board[row][column] == who:
                    for dirct in directions:
                        moves.append(inverseGetLine(board, who, (row, column), dirct))

    try:
        while True: moves.remove([])
    except ValueError:
        pass

    return list(set(moves))

def makeMove(board, move, who):

    moves = []

    for dirct in directions:
        moves.append(getLine(board, who, move, dirct))

    moves = sum(moves,
                [move])

    for cell in (moves):
        if cell != []:
            board[cell[0]][cell[1]] = who

    return board


def scoreBoard(board):

    values = sum(board, [])
    return (values.count(1) - values.count(2))

def suggestMove1(board, who):

    potentialScore = scoreBoard(board)
    potentialMove = ()

    validMoves = getValidMoves(board, who)

    for mvt in validMoves:
        tempBoard = deepcopy(board)
        newScore = scoreBoard(makeMove(tempBoard, mvt, who))
        if (((-1) ** (who + 1)) * newScore + ((-1) ** who) * potentialScore) >= 0:
            potentialScore = newScore
            potentialMove = mvt

    return potentialMove

def suggestMove2(board, who):

    values = [[6, -5, 5, 3, 3, 5, -5, 6],
              [-5, -6, -2, -1, -1, -2, -6, -5],
              [5, -2, 4, 2, 2, 4, -2, 5],
              [3, -1, 2, 0, 0, 2, -1, 3],
              [3, -1, 2, 0, 0, 2, -1, 3],
              [5, -2, 4, 2, 2, 4, -2, 5],
              [-5, -6, -2, -1, -1, -2, -6, -5],
              [6, -5, 5, 3, 3, 5, -5, 6]]

    curBoard = deepcopy(board)
    potentialScore = scoreBoard(board)
    validMoves = getValidMoves(board, who)

    def tryMove(board, move, who):

        tempBoard = deepcopy(board)
        makeMove(tempBoard, move, who)
        return tempBoard

    def evalMove(validMove):

        validMove = [validMove]
        validMove.append(values[validMove[0][0]][validMove[0][1]])
        return validMove

    def mobility(validMove):

        validMove.append(tryMove(curBoard, validMove[0], who))
        validMove.append(len(getValidMoves(validMove[2], who)) -
                         len(getValidMoves(validMove[2], 3 - who)))
        return validMove

    def futureScore(validMove):

        validMove.append(((-1) ** (who + 1)) * scoreBoard(validMove[2]) + (
                    (-1) ** who) * potentialScore)
        return validMove

    approach = [[evalMove, 1], [mobility, 3], [futureScore, 4]]

    cycle = 0
    while (len(validMoves) > 1) and (cycle <= 2):
        func = approach[cycle][0]
        param = approach[cycle][1]

        validMoves[:] = map(func, validMoves)
        validMoves.sort(key=lambda validMove: validMove[param], reverse=True)
        validMoves = list(filter(lambda validMove: validMove[param] == validMoves[0][param],
                                 validMoves))
        cycle += 1

    if validMoves == []:
        return None
    elif type(validMoves[0]) == tuple:
        return validMoves[0]

    return validMoves[0][0]

#Main function
def play():

    print("\n" "WELCOME TO OTHELLO GAME!" )
    print("Enter the players names, or 'C' to play against the computer.\n")

    def myInput(string):

        while True:
            val = input(string).lower().capitalize()
            if val: break
        return val

    players = [myInput("Player 1: "), myInput("Player 2: ")]

    global game, board, who

    if 'L' in players:
        game = loadGame()
    else:
        game = newGame(*players)

    board = game['board']
    who = int(game['who'])

    def playerToName(who, sign=0):

        return (game['player' + str(who).strip()] + sign * [' (X)', ' (O)'][who - 1]).strip()

    skipped = False

    while True:
        printBoard(board)
        validMoves = getValidMoves(board, who)

        if validMoves == []:
            if skipped:
                score = scoreBoard(board)
                if score == 0:
                    print("Draw. Friendship wins!")
                else:
                    winner = int(1.5 - 0.5 * (score / abs(score)))
                    print(playerToName(winner, 1) +
                          " wins with a score of " +
                          str(abs(score)))
                break

            print("No valid moves for " + playerToName(who, 1))
            skipped = True
        else:
            if playerToName(who) == 'C':
                compMove = suggestMove1(board, who)
                print("Computer" + [' (X)', ' (O)'][who - 1] + " moves to ", end='')
                time.sleep(abs(compMoveDelay))
                print(indexToStr(compMove))
                makeMove(board, compMove, who)

            else:
                playerMove = strToIndex(input(str(playerToName(who, 1)) + " moves to: "))
                makeMove(board, playerMove, who)

        who = 3 - who

    return

if __name__ == '__main__' or __name__ == 'builtins':
    play()
